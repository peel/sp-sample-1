* Users API Assignment

** Considerations and corners cut
For excercise purposes I decided to choose Http4s as a familiar http server and DSL.
Http4s falls in nicely with monadic approach of Grafter 
(which I haven't worked with and still am on a fence with its design choices).
This allows to keep the matters isolated and highly scalable, contained and fairly simple.
Due to time restrictions some corners have been cut, mostly:
- authentication/authorization is not implemented (hints on ~AuthMiddleware~ below)
- content negotiation as a better way of versioning and response structuring (hinted within ~Versioning~ section)
- http routes structure within a single ~Http~ module could be expanded into separate modules fetched via ~Reader~ monad
- effect type of ~cats.effect.IO~ should ba parameterised within ~Http~ module

** Versioning
Versioning has been a common issue with REST-like APIs. 
The simplier, yet less-favourable, approach taken in the current version of 
the application is to simply encode version within the endpoint.
This approach usually allows for enough flexibility for major changes 
at a cost of high code duplication.
A far better approach to take would be to use content negotiation
as purely RESTful and easier to maintain approach. 
In terms of Http4s, that would mean we can have two separate functions 
within a single endpoint, which leads to less duplication, more flexibity 
and easier testing. 
This approach is more involved and although I would consider following that 
route in production code, due to time-constraints I explicitly decided not 
to do that in scope of the task.

** Exception handling
One of the benefits of Http4s is the composable nature of http routes, which means
they are pretty much instances of ~Kleisli[F, Request[F], Response[F]]~.
This allows for simple composition within effect types (higher kind types).
Henceforth this will allow for expressing a discrete set of routes 
(that with more time could be fetched through separate hierarchy of ~Reader~ monads)
and share the error handling among them.

** Data sharing and admin/end-user endpoints
The endpoints are separated as if they are to be exposed through separate
pipelines using Http4s' ~AuthMiddleware~ which allows for access restrictions
for specific parts of the API.
Some of the endpoints that would be otherwise duplicates of admin-like functionality, could be
exposed to end-users could be piped through lens so only part of the object is serialized.
This could be easily doable ~Content-Type~ negotiation and vendor-specific content types. 
This would keep the codebase coincise and allow for code sharing whereas only
the needed components are pushed over the wire, ie password is not sent through public/user endpoints.
It can be discussed whether it should be available within admin API, but keeping it to prove the
purpose.
For now the duplicates that only change the response structure are not duplicated due to time constraints.
Moreover, for better concern separation it might be beneficial to provide an option to separately host both
enduser and internal api, much like following run method that exposes two separately-configured APIs.

#+BEGIN_SRC scala
    val public = Application.fromApplicationConfig
       .run(config)
       .http
       .stream

    val admin = Application.fromApplicationConfig
       .run(configAdmin)
       .http
       .stream

    public
      .concurrently(admin)
      .compile
      .drain
      .as(ExitCode.Success)
#+END_SRC

** Consistency
In order to achieve HTTP code reason and consistency, given the time bounds, some inconsistency is introduced
in ~Http~ module. This can be further ironed out on a longer time span.
